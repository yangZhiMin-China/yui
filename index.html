<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>yui</title>
    <link rel="icon" type="image/x-icon" href="/public/logo.png"/>
    <link rel="stylesheet" type="text/css" href="yui/iconfont.css">
</head>
<body>
<canvas></canvas>
<div class="text">
    <div style="text-align: center">
        <div>yui - Element UI 部分组件的HTML使用</div>
        <div style="margin-top: 30px">
            <a id="start" href="./components/alert/index.html" target="_blank">
                Get Start
                <i style="position: relative" class="iconfont yui-enter"></i>
            </a>
            <a style="margin:0 50px" href="https://github.com/yangZhiMin-China/yui" target="_blank">
                GitHub
                <i class="iconfont yui-enter"></i>
            </a>
            <a id="support">
                Support
                <span class="support-icon">
                    <i style="font-size: 14px" class="iconfont yui-drop-down"></i>
                </span>
            </a>
        </div>
        <div class="donate">
            <img src="./public/images/alipay.png" alt="支付宝支付">
            <img style="margin-left: 10px" src="./public/images/wechat.png" alt="微信支付">
        </div>
    </div>
</div>
<div class="info">
    <div class="title">使用说明</div>
    <div class="desc">
        点击下载
        <a href="release/yui.rar" download="yui.rar">yui压缩包</a>
        ，包含 CSS 、JS 以及 Iconfont（属于css文件）三个文件。
        将文件解压缩，放在你的个人项目中，在你的项目文件（一般是html文件）中正确地引用这三个文件即可看到yui效果。
        组件的示例代码请点击
        <a href="./components/alert/index.html">
            开始
        </a>。
    </div>
    <div class="title" style="margin-top: 50px">引用语句</div>
    <div class="desc">
        &lt;link rel="stylesheet" type="text/css" href="/yourPath/yui/yui-min.css"&gt;
    </div>
    <div class="desc">
        &lt;link rel="stylesheet" type="text/css" href="/yourPath/yui/iconfont-min.css"&gt;
    </div>
    <div class="desc">
        &lt;script type="text/javascript" src="/yourPath/yui/yui-min.js"&gt;&lt;/script&gt;
    </div>
</div>
</body>
<script>
    supportHover();
    startHover();

    function supportHover() {
        let dom = document.querySelector('#support');
        let icon = dom.querySelector('span');
        let imgDom = document.querySelector('.donate');
        imgDom.style.height = "0px";
        let STO = '';
        dom.addEventListener("mouseenter", function () {
            if (STO) {
                clearTimeout(STO);
            }
            icon.style.transform = "rotate(180deg)";
            imgDom.style.visibility = "visible";
            imgDom.style.height = "500px";
        });
        dom.addEventListener("mouseleave", function () {
            icon.style.transform = "rotate(0deg)";
            imgDom.style.height = "0px";
            STO = setTimeout(() => {
                imgDom.style.visibility = "hidden";
            }, 500)
        })
    }

    function startHover() {
        let dom = document.querySelector('#start');
        let iconDom = dom.querySelector("i");
        let num = 1;
        setInterval(() => {
            if (num > 8) {
                num = 0
            }
            iconDom.style.left = num + "px";
            num++
        }, 80)
    }
</script>
<style>
    .donate {
        display: inline-flex;
        position: relative;
        left: -10%;
        margin-top: 10px;
        overflow: hidden;
        visibility: hidden;
        transition: height .5s;
        padding: 5px;
        z-index: 2020;
    }

    .donate img {
        border-radius: 5px;
        width: 400px;
    }

    .support-icon {
        display: inline-block;
        transition: transform .5s;
        position: relative;
    }

    body {
        background-color: black;
        overflow: hidden;
    }

    canvas {
        width: 100%;
    }

    .text {
        font-size: 32px;
        color: white;
        position: absolute;
        width: 100%;
        top: 15%;
        left: 0;
        z-index: 2020;
    }

    a {
        font-size: 18px;
        color: white;
        text-decoration: none;
        cursor: pointer;
    }

    .info {
        margin-top: 100px;
        width: 600px;
        border: 1px dashed white;
        border-radius: 5px;
        padding: 10px;
        position: absolute;
        bottom: 3px;
        right: 3px;
        color: white;
        text-align: center;
    }

    .info > .title {
        font-size: 18px;
        margin: 5px 0;
    }

    .info > .desc {
        font-size: 15px;
        margin: 12px 0;
        text-align: left;
        padding: 5px;
        text-indent: 2em;
        line-height: 25px;
    }

    .desc a {
        cursor: pointer;
        font-size: 15px;
        text-decoration: underline;
    }
</style>
<script>
    const canvas = document.querySelector('canvas');
    const ctx = canvas.getContext('2d');

    const RESOLUTION = 1;

    let w = canvas.width = window.innerWidth * RESOLUTION;
    let h = canvas.height = window.innerHeight * RESOLUTION;

    const PARTICLE_COUNT = 400;
    const CONNECT_DISTANCE = w * 0.05;
    const FORCE_DISTANCE = w * 0.1;

    const r = (n = 1) => Math.random() * n;
    const PI = Math.PI;
    const TAU = PI * 2;

    let time = new Date();

    const lerp = (start, end, amt) => {
        return (1 - amt) * start + amt * end;
    };

    const distance = (x1, y1, x2, y2) => {
        const a = x1 - x2;
        const b = y1 - y2;
        return Math.sqrt(a * a + b * b);
    };

    const angle = (cx, cy, ex, ey) => {
        return Math.atan2(ey - cy, ex - cx);
    };

    const particlePrototype = () => ({
        x: w * 0.5 + Math.cos(r(TAU)) * r(w * 0.5),
        y: h * 0.5 + Math.sin(r(TAU)) * r(h * 0.5),
        angle: r(TAU),
        speed: r(0.15),
        normalSpeed: r(0.15),
        oscAmplitudeX: r(2),
        oscSpeedX: 0.001 + r(0.008),
        oscAmplitudeY: r(2),
        oscSpeedY: 0.001 + r(0.008),
        connectDistance: r(CONNECT_DISTANCE),
        color: {
            r: Math.round(200 + r(55)),
            g: Math.round(150 + r(105)),
            b: Math.round(200 + r(55))
        }
    });


    const particles = new Array(PARTICLE_COUNT).fill({}).map(particlePrototype);

    const update = () => {
        particles.forEach(p1 => {
            p1.x += (Math.cos(p1.angle) + Math.cos(time * p1.oscSpeedX) * p1.oscAmplitudeX) * p1.speed;
            p1.y += (Math.sin(p1.angle) + Math.cos(time * p1.oscSpeedY) * p1.oscAmplitudeY) * p1.speed;

            p1.speed = lerp(p1.speed, p1.normalSpeed * RESOLUTION, 0.1);

            if (p1.x > w || p1.x < 0) {
                p1.angle = PI - p1.angle;
            }
            if (p1.y > h || p1.y < 0) {
                p1.angle = -p1.angle;
            }

            if (r() < 0.005)
                p1.oscAmplitudeX = r(2);
            if (r() < 0.005)
                p1.oscSpeedX = 0.001 + r(0.008);
            if (r() < 0.005)
                p1.oscAmplitudeY = r(2);
            if (r() < 0.005)
                p1.oscSpeedY = 0.001 + r(0.008);

            p1.x = Math.max(-0.01, Math.min(p1.x, w + 0.01));
            p1.y = Math.max(-0.01, Math.min(p1.y, h + 0.01));
        });
    };

    const render = () => {

        ctx.clearRect(0, 0, w, h);

        particles.map(p1 => {
            particles.filter(p2 => {
                if (p1 == p2)
                    return false;
                if (distance(p1.x, p1.y, p2.x, p2.y) > p1.connectDistance)
                    return false;
                return true;
            }).map(p2 => {
                const dist = distance(p1.x, p1.y, p2.x, p2.y);
                p1.speed = lerp(p1.speed, p1.speed + 0.05 / p1.connectDistance * dist, 0.2);
                return {
                    p1,
                    p2,
                    color: p1.color,
                    opacity: Math.floor(100 / p1.connectDistance * (p1.connectDistance - dist)) / 100
                };

            }).forEach((line, i) => {
                const colorSwing = Math.sin(time * line.p1.oscSpeedX);
                ctx.beginPath();
                ctx.globalAlpha = line.opacity;
                ctx.moveTo(line.p1.x, line.p1.y);
                ctx.lineTo(line.p2.x, line.p2.y);
                ctx.strokeStyle = `rgb(
					${Math.floor(line.color.r * colorSwing)},
					${Math.floor(line.color.g * 0.5 + line.color.g * 0.5 * colorSwing)},
					${line.color.b}
				)`;
                ctx.lineWidth = line.opacity * 4;
                ctx.stroke();
                ctx.closePath();
            });
        });

    };

    const loop = () => {
        time = new Date();
        update();
        render();
        window.requestAnimationFrame(loop);
    };

    loop();

    window.addEventListener('mousemove', e => {

        const mouseX = e.layerX * RESOLUTION;
        const mouseY = e.layerY * RESOLUTION;

        particles.forEach(p => {
            const dist = distance(mouseX, mouseY, p.x, p.y);

            if (dist < FORCE_DISTANCE && dist > 0) {
                p.angle = angle(mouseX, mouseY, p.x, p.y);
                const force = (FORCE_DISTANCE - dist) * 0.1;
                p.speed = lerp(p.speed, force, 0.2);
            }
        });

    });

    window.addEventListener('resize', e => {
        w = canvas.width = window.innerWidth * RESOLUTION;
        h = canvas.height = window.innerHeight * RESOLUTION;
    });
</script>
</html>